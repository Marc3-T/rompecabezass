<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rompecabezas 4x5 - 8mm</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #FFF0F5; /* Rosa lavanda claro */
            color: #8B5F8D; /* Rosa oscuro */
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #D291BC; /* Rosa medio */
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 400px;
            margin-bottom: 15px;
            background-color: #FFE4E6; /* Rosa muy claro */
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .game-info div {
            text-align: center;
        }

        .game-info span {
            font-weight: bold;
            color: #C71585; /* Rosa vibrante */
        }

        .puzzle-container {
            width: 100%;
            max-width: 400px;
            height: 500px;
            background-color: #FFE4E6; /* Rosa muy claro */
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            overflow: hidden;
            position: relative;
        }

        .puzzle-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(5, 1fr);
            width: 100%;
            height: 100%;
            gap: 2px;
            padding: 2px;
        }

        .puzzle-piece {
            background-color: #FFB6C1; /* Rosa pastel */
            border-radius: 5px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            user-select: none;
            position: relative;
        }

        .puzzle-piece img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .puzzle-piece.empty {
            background-color: transparent;
            cursor: default;
        }

        .puzzle-piece.movable:hover {
            background-color: #FF91A4; /* Rosa más intenso */
            transform: scale(0.98);
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            background-color: #D291BC; /* Rosa medio */
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #C71585; /* Rosa vibrante */
        }

        .instructions {
            background-color: #FFE4E6; /* Rosa muy claro */
            padding: 15px;
            border-radius: 10px;
            max-width: 400px;
            margin-top: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .instructions h2 {
            font-size: 18px;
            margin-bottom: 10px;
            color: #D291BC; /* Rosa medio */
        }

        .instructions p {
            margin-bottom: 8px;
            font-size: 14px;
        }

        .win-message {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 228, 230, 0.9); /* Rosa muy claro con transparencia */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
            z-index: 10;
        }

        .win-message.show {
            opacity: 1;
            pointer-events: all;
        }

        .win-message h2 {
            font-size: 24px;
            margin-bottom: 15px;
            color: #C71585; /* Rosa vibrante */
        }

        .image-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid rgba(255, 182, 193, 0.3);
            border-radius: 50%;
            border-top: 4px solid #D291BC;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <header>
        <h1>Rompecabezas 4x5 - 8mm</h1>
    </header>
    
    <div class="game-info">
        <div>Movimientos: <span id="move-count">0</span></div>
        <div>Tiempo: <span id="timer">00:00</span></div>
    </div>
    
    <div class="puzzle-container">
        <div class="image-loading" id="loading">
            <div class="spinner"></div>
            <p>Cargando imagen...</p>
        </div>
        <div class="puzzle-grid" id="puzzle-grid">
            <!-- Las piezas se generarán con JavaScript -->
        </div>
        <div class="win-message" id="win-message">
            <h2>¡Felicidades!</h2>
            <p>Has completado el rompecabezas</p>
            <button id="play-again">Jugar otra vez</button>
        </div>
    </div>
    
    <div class="controls">
        <button id="shuffle-btn">Mezclar</button>
        <button id="reset-btn">Reiniciar</button>
    </div>
    
    <div class="instructions">
        <h2>Instrucciones</h2>
        <p>• Toca una pieza adyacente al espacio vacío para moverla</p>
        <p>• Ordena las piezas para completar la imagen</p>
        <p>• Intenta resolverlo en el menor tiempo y con la menor cantidad de movimientos</p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const puzzleGrid = document.getElementById('puzzle-grid');
            const shuffleBtn = document.getElementById('shuffle-btn');
            const resetBtn = document.getElementById('reset-btn');
            const moveCountElement = document.getElementById('move-count');
            const timerElement = document.getElementById('timer');
            const winMessage = document.getElementById('win-message');
            const playAgainBtn = document.getElementById('play-again');
            const loadingElement = document.getElementById('loading');
            
            const ROWS = 5;
            const COLS = 4;
            const TOTAL_PIECES = ROWS * COLS - 1; // 19 piezas + 1 espacio vacío
            
            // URL de la imagen en GitHub - reemplaza con tu URL real
            const IMAGE_URL = 'https://raw.githubusercontent.com/tu-usuario/tu-repositorio/main/8mm.JPG';
            
            let pieces = [];
            let emptyIndex = TOTAL_PIECES; // El último índice es el espacio vacío
            let moveCount = 0;
            let timer = 0;
            let timerInterval;
            let isGameActive = false;
            let imageLoaded = false;
            let originalImage;
            
            // Cargar la imagen
            function loadImage() {
                originalImage = new Image();
                originalImage.crossOrigin = "Anonymous";
                originalImage.onload = function() {
                    imageLoaded = true;
                    loadingElement.style.display = 'none';
                    initPuzzle();
                };
                originalImage.onerror = function() {
                    loadingElement.innerHTML = '<p>Error al cargar la imagen. Verifica la URL.</p>';
                };
                originalImage.src = IMAGE_URL;
            }
            
            // Inicializar el rompecabezas
            function initPuzzle() {
                if (!imageLoaded) return;
                
                puzzleGrid.innerHTML = '';
                pieces = [];
                
                // Crear piezas ordenadas
                for (let i = 0; i < TOTAL_PIECES; i++) {
                    pieces.push(i);
                }
                pieces.push(null); // El espacio vacío
                
                renderPuzzle();
                updateMoveCount();
                resetTimer();
            }
            
            // Renderizar el rompecabezas
            function renderPuzzle() {
                puzzleGrid.innerHTML = '';
                
                pieces.forEach((pieceIndex, index) => {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = 'puzzle-piece';
                    
                    if (pieceIndex === null) {
                        pieceElement.classList.add('empty');
                    } else {
                        // Crear el recorte de imagen para esta pieza
                        const img = document.createElement('img');
                        img.src = originalImage.src;
                        
                        // Calcular posición del recorte
                        const row = Math.floor(pieceIndex / COLS);
                        const col = pieceIndex % COLS;
                        const x = (col / COLS) * 100;
                        const y = (row / ROWS) * 100;
                        const width = 100 / COLS;
                        const height = 100 / ROWS;
                        
                        img.style.objectPosition = `-${x}% -${y}%`;
                        img.style.width = `${COLS * 100}%`;
                        img.style.height = `${ROWS * 100}%`;
                        
                        pieceElement.appendChild(img);
                        pieceElement.classList.add('movable');
                        
                        // Verificar si la pieza es adyacente al espacio vacío
                        if (isAdjacent(index, emptyIndex)) {
                            pieceElement.addEventListener('click', () => movePiece(index));
                        }
                    }
                    
                    puzzleGrid.appendChild(pieceElement);
                });
            }
            
            // Verificar si dos índices son adyacentes
            function isAdjacent(index1, index2) {
                const row1 = Math.floor(index1 / COLS);
                const col1 = index1 % COLS;
                const row2 = Math.floor(index2 / COLS);
                const col2 = index2 % COLS;
                
                return (Math.abs(row1 - row2) === 1 && col1 === col2) || 
                       (Math.abs(col1 - col2) === 1 && row1 === row2);
            }
            
            // Mover una pieza
            function movePiece(index) {
                if (!isGameActive) {
                    startTimer();
                    isGameActive = true;
                }
                
                // Intercambiar la pieza con el espacio vacío
                [pieces[index], pieces[emptyIndex]] = [pieces[emptyIndex], pieces[index]];
                emptyIndex = index;
                
                moveCount++;
                updateMoveCount();
                renderPuzzle();
                
                // Verificar si el rompecabezas está resuelto
                if (isSolved()) {
                    endGame();
                }
            }
            
            // Verificar si el rompecabezas está resuelto
            function isSolved() {
                for (let i = 0; i < TOTAL_PIECES; i++) {
                    if (pieces[i] !== i) {
                        return false;
                    }
                }
                return pieces[TOTAL_PIECES] === null;
            }
            
            // Mezclar las piezas
            function shufflePieces() {
                resetTimer();
                moveCount = 0;
                updateMoveCount();
                isGameActive = false;
                
                // Algoritmo de mezcla: realizar movimientos válidos aleatorios
                const shuffleMoves = 200;
                let lastMovedIndex = -1;
                
                for (let i = 0; i < shuffleMoves; i++) {
                    const adjacentIndices = [];
                    
                    // Encontrar todas las piezas adyacentes al espacio vacío
                    for (let j = 0; j < pieces.length; j++) {
                        if (pieces[j] !== null && isAdjacent(j, emptyIndex) && j !== lastMovedIndex) {
                            adjacentIndices.push(j);
                        }
                    }
                    
                    // Elegir una pieza aleatoria para mover
                    if (adjacentIndices.length > 0) {
                        const randomIndex = Math.floor(Math.random() * adjacentIndices.length);
                        const pieceToMove = adjacentIndices[randomIndex];
                        
                        // Mover la pieza
                        [pieces[pieceToMove], pieces[emptyIndex]] = [pieces[emptyIndex], pieces[pieceToMove]];
                        lastMovedIndex = emptyIndex;
                        emptyIndex = pieceToMove;
                    }
                }
                
                renderPuzzle();
                winMessage.classList.remove('show');
            }
            
            // Actualizar el contador de movimientos
            function updateMoveCount() {
                moveCountElement.textContent = moveCount;
            }
            
            // Iniciar el temporizador
            function startTimer() {
                clearInterval(timerInterval);
                timer = 0;
                updateTimer();
                timerInterval = setInterval(() => {
                    timer++;
                    updateTimer();
                }, 1000);
            }
            
            // Actualizar el temporizador
            function updateTimer() {
                const minutes = Math.floor(timer / 60).toString().padStart(2, '0');
                const seconds = (timer % 60).toString().padStart(2, '0');
                timerElement.textContent = `${minutes}:${seconds}`;
            }
            
            // Reiniciar el temporizador
            function resetTimer() {
                clearInterval(timerInterval);
                timer = 0;
                updateTimer();
            }
            
            // Finalizar el juego
            function endGame() {
                clearInterval(timerInterval);
                isGameActive = false;
                winMessage.classList.add('show');
            }
            
            // Event listeners
            shuffleBtn.addEventListener('click', shufflePieces);
            resetBtn.addEventListener('click', initPuzzle);
            playAgainBtn.addEventListener('click', () => {
                initPuzzle();
                winMessage.classList.remove('show');
            });
            
            // Inicializar el juego cargando la imagen
            loadImage();
        });
    </script>
</body>
</html>
